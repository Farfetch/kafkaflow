"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3780],{28453:(e,n,d)=>{d.d(n,{R:()=>a,x:()=>t});var r=d(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},89850:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>o});var r=d(74848),s=d(28453);const i={sidebar_position:2},a="Typed Handler Middleware",t={id:"guides/middlewares/typed-handler-middleware",title:"Typed Handler Middleware",description:"In this section, we will learn how to use the Typed Handler middleware.",source:"@site/docs/guides/middlewares/typed-handler-middleware.md",sourceDirName:"guides/middlewares",slug:"/guides/middlewares/typed-handler-middleware",permalink:"/kafkaflow/docs/guides/middlewares/typed-handler-middleware",draft:!1,unlisted:!1,editUrl:"https://github.com/farfetch/kafkaflow/tree/master/website/docs/guides/middlewares/typed-handler-middleware.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Middleware Introduction",permalink:"/kafkaflow/docs/guides/middlewares/"},next:{title:"Serializer Middleware",permalink:"/kafkaflow/docs/guides/middlewares/serializer-middleware"}},l={},o=[{value:"How Message Type is discovered",id:"how-message-type-is-discovered",level:3},{value:"With Schema Registry",id:"with-schema-registry",level:4},{value:"Without Schema Registry",id:"without-schema-registry",level:4},{value:"Configure Typed Handler",id:"configure-typed-handler",level:2},{value:"Create a Message Handler",id:"create-a-message-handler",level:2},{value:"Configuring Handler Lifetime",id:"configuring-handler-lifetime",level:2},{value:"Handling No Handler Found event",id:"handling-no-handler-found-event",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"typed-handler-middleware",children:"Typed Handler Middleware"}),"\n",(0,r.jsx)(n.p,{children:"In this section, we will learn how to use the Typed Handler middleware."}),"\n",(0,r.jsx)(n.p,{children:"The Typed Handler Middleware allows you to execute different handlers depending on the message type."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Use it when the topic has different message types."})}),"\n",(0,r.jsx)(n.p,{children:"When a message with a given type arrives, the middleware will call the appropriate message handler for that message type."}),"\n",(0,r.jsx)(n.h3,{id:"how-message-type-is-discovered",children:"How Message Type is discovered"}),"\n",(0,r.jsx)(n.p,{children:"The Message Type discovery may vary depending on the implementation."}),"\n",(0,r.jsx)(n.h4,{id:"with-schema-registry",children:"With Schema Registry"}),"\n",(0,r.jsxs)(n.p,{children:["When using a Schema Registry, the schema is read from it, and the first 5 bytes of the message represent the ",(0,r.jsx)(n.code,{children:"SchemaId"})," registered on the Schema Registry."]}),"\n",(0,r.jsx)(n.h4,{id:"without-schema-registry",children:"Without Schema Registry"}),"\n",(0,r.jsxs)(n.p,{children:["Using other serializers with no Schema Registry, the ",(0,r.jsx)(n.code,{children:"DefaultTypeResolver"})," is used by default. The ",(0,r.jsx)(n.code,{children:"DefaultTypeResolver"})," uses the header ",(0,r.jsx)(n.code,{children:"Message-Type"})," to identify the message type based on the Type fully qualified name."]}),"\n",(0,r.jsxs)(n.p,{children:["It's also possible to write your own ",(0,r.jsx)(n.code,{children:"TypeResolver"})," implementing the ",(0,r.jsx)(n.code,{children:"IMessageTypeResolver"})," interface and using it in the ",(0,r.jsx)(n.code,{children:"AddSerializer"}),"/",(0,r.jsx)(n.code,{children:"AddDeserializer"})," method in the consumer/producer middleware."]}),"\n",(0,r.jsx)(n.h2,{id:"configure-typed-handler",children:"Configure Typed Handler"}),"\n",(0,r.jsx)(n.p,{children:"There are three ways to add handlers to a consumer:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"AddHandler<HandlerType>()"}),":"]})," adds one handler per call."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"AddHandlers(IEnumerable<Type> handlers)"}),":"]})," adds many handlers per call."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"AddHandlersFromAssemblyOf<HandlerType>()"}),":"]})," adds all classes on the given assembly type that implement the ",(0,r.jsx)(n.code,{children:"IMessageHandler"})," interface."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'services.AddKafka(kafka => kafka\n    .AddCluster(cluster => cluster\n        .WithBrokers(new[] { "localhost:9092" })\n        .AddConsumer(consumer => consumer\n            ...\n            .AddMiddlewares(middlewares => middlewares\n                ...\n                .AddTypedHandlers(handlers => handlers\n                    .WithHandlerLifetime(InstanceLifetime.Singleton)\n                    .AddHandler<ProductCreatedHandler>()\n                    // or\n                    .AddHandlers( ... )\n                    // or\n                    .AddHandlersFromAssemblyOf<ProductCreatedHandler>()\n                )\n            )\n        )\n    )\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"create-a-message-handler",children:"Create a Message Handler"}),"\n",(0,r.jsxs)(n.p,{children:["A message handler can be created by implementing the ",(0,r.jsx)(n.code,{children:"IMessageHandler<MessageType>"})," interface."]}),"\n",(0,r.jsx)(n.p,{children:"The handler's instance is created by the configured dependency injection container, any handler dependency will be injected through the constructor, and the instance lifetime can be configured in the configuration."}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"If there's no handler defined for the arriving message, it will be ignored."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class ProductCreatedHandler : IMessageHandler<ProductCreatedEvent>\n{\n    public Task Handle(IMessageContext context, ProductCreatedEvent message)\n    {\n        ...\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-handler-lifetime",children:"Configuring Handler Lifetime"}),"\n",(0,r.jsx)(n.p,{children:"The Handler lifetime can be configured to one of the following modes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Singleton:"})," A single class instance will be created for the entire application."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scoped:"})," A new class instance will be created for each scope."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transient:"})," A new class instance will be created every time it is requested."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"By default, the handler lifetime is Singleton."})}),"\n",(0,r.jsx)(n.h2,{id:"handling-no-handler-found-event",children:"Handling No Handler Found event"}),"\n",(0,r.jsx)(n.p,{children:"If there's no handler defined for the arriving message, it will be ignored."}),"\n",(0,r.jsx)(n.p,{children:"It is possible to handle those events. As an example, the following code writes to the console when a message can't be handled."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'services.AddKafka(kafka => kafka\n    .AddCluster(cluster => cluster\n        .WithBrokers(new[] { "localhost:9092" })\n        .AddConsumer(consumer => consumer\n            ...\n            .AddMiddlewares(middlewares => middlewares\n                ...\n                .AddTypedHandlers(handlers => handlers\n                    .AddHandler<ProductCreatedHandler>()\n                    .WhenNoHandlerFound(context => \n                        Console.WriteLine("Message not handled > Partition: {0} | Offset: {1}",\n                            context.ConsumerContext.Partition,\n                            context.ConsumerContext.Offset)\n                        )\n                )\n            )\n        )\n    )\n);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);