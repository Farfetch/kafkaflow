"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1634],{34073:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>t,metadata:()=>i,toc:()=>l});var n=r(85893),a=r(11151);const t={},o="IMessageConsumer interface",i={id:"reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/IMessageConsumer",title:"IMessageConsumer interface",description:"Provides access to the kafka message consumer",source:"@site/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/IMessageConsumer.md",sourceDirName:"reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer",slug:"/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/",permalink:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/",draft:!1,unlisted:!1,editUrl:"https://github.com/farfetch/kafkaflow/tree/master/website/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/IMessageConsumer.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IConsumerMiddlewareContext.Worker property",permalink:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IConsumerMiddlewareContext/Worker"},next:{title:"IMessageConsumer.Assignment property",permalink:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Assignment"}},c={},l=[{value:"Members",id:"members",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"imessageconsumer-interface",children:"IMessageConsumer interface"}),"\n",(0,n.jsx)(s.p,{children:"Provides access to the kafka message consumer"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-csharp",children:"public interface IMessageConsumer\n"})}),"\n",(0,n.jsx)(s.h2,{id:"members",children:"Members"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"name"}),(0,n.jsx)(s.th,{children:"description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Assignment",children:"Assignment"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the current partition assignment"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/ClientInstanceName",children:"ClientInstanceName"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the name of this client instance. Contains (but is not equal to) the client.id configuration parameter."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/ClusterName",children:"ClusterName"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the unique cluster\xb4s name defined in the configuration"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/ConsumerName",children:"ConsumerName"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the unique consumer\xb4s name defined in the configuration"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/GroupId",children:"GroupId"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the group id define in the configuration"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/ManagementDisabled",children:"ManagementDisabled"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets a value indicating whether the consumer is able to be manageable or not"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/MemberId",children:"MemberId"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the (dynamic) group member id of this consumer (as set by the broker)."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/PausedPartitions",children:"PausedPartitions"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the consumer's paused partitions"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/RunningPartitions",children:"RunningPartitions"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the consumer's running partitions"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Status",children:"Status"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the current consumer status"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Subscription",children:"Subscription"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the current topic subscription"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Topics",children:"Topics"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the consumer configured topics"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/WorkersCount",children:"WorkersCount"}),"\xa0{\xa0get;\xa0}"]}),(0,n.jsx)(s.td,{children:"Gets the current number of workers allocated of the consumer"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/ChangeWorkersCountAndRestartAsync",children:"ChangeWorkersCountAndRestartAsync"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Restart the current consumer with the new worker count"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/GetOffsets",children:"GetOffsets"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/GetPosition",children:"GetPosition"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Gets the current position (offset) for the specified topic / partition. The offset field of each requested partition will be set to the offset of the last consumed message + 1, or Offset.Unset in case there was no previous message consumed by this consumer."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/GetTopicPartitionsLag",children:"GetTopicPartitionsLag"}),"()"]}),(0,n.jsx)(s.td,{children:"Gets the lag of each topic/partitions assigned"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/GetWatermarkOffsets",children:"GetWatermarkOffsets"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Get the last cached low (oldest available / beginning) and high (newest/end) offsets for a topic/partition. Does not block."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/OverrideOffsetsAndRestartAsync",children:"OverrideOffsetsAndRestartAsync"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Overrides the offsets of the given partitions and restart the consumer"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Pause",children:"Pause"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Pause consumption for the provided list of partitions."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/QueryWatermarkOffsets",children:"QueryWatermarkOffsets"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Query the Kafka cluster for low (oldest available/beginning) and high (newest/end) offsets for the specified topic/partition. This is a blocking call - always contacts the cluster for the required information."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/RestartAsync",children:"RestartAsync"}),"()"]}),(0,n.jsx)(s.td,{children:"Restart KafkaFlow consumer and recreate the internal Confluent Consumer"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/Resume",children:"Resume"}),"(\u2026)"]}),(0,n.jsx)(s.td,{children:"Resume consumption for the provided list of partitions."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/StartAsync",children:"StartAsync"}),"()"]}),(0,n.jsx)(s.td,{children:"Starts KafkaFlow consumer creating a new Confluent Consumer"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/KafkaFlow.Consumers/IMessageConsumer/StopAsync",children:"StopAsync"}),"()"]}),(0,n.jsx)(s.td,{children:"Stops KafkaFlow consumer destroying the Confluent Consumer"})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"see-also",children:"See Also"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["namespace\xa0",(0,n.jsx)(s.a,{href:"/kafkaflow/docs/reference/KafkaFlow/",children:"KafkaFlow.Consumers"})]}),"\n"]})]})}function f(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,s,r)=>{r.d(s,{Z:()=>i,a:()=>o});var n=r(67294);const a={},t=n.createContext(a);function o(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);